%% Grammar for the SugarTest language
%% Modified copy of Stratego Test language
module SugarTest

imports Common
imports languages/aterm/syntax/ATerms

exports
  context-free start-symbols TestSuite

exports
  sorts TestSuite Test Input Output Desugar Result
  context-free syntax
    Header TestDecl*   -> TestSuite {cons("testsuite")}
    "language" ID      -> Header {cons("Language")}

    Test         -> TestDecl

  %% The description syntax is very ambiguous if comments are allowed around it. So, we forbid comments.
  syntax
    
    "setup" <OptSpace-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> -> <Test-CF> {cons("Setup")}
    "setup" <OptSpace-LEX> <Description-CF>                         -> <Test-CF> {cons("SetupEmpty")}

    "test" <OptSpace-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result*-CF> -> <Test-CF> {cons("Test")}
    "test" <OptSpace-LEX> <Description-CF> -> <Test-CF> {cons("TestEmpty")}

  lexical syntax
    [\ ]+   -> OptSpace
    NoSpace -> OptSpace
            -> NoSpace

  lexical restrictions
    OptSpace -/- [\ ]
    NoSpace  -/- ~[\[].~[\[]

  context-free syntax

    "parse" "to" ATerm   -> Result {cons("pattern")}
    "parse" "to" Output   -> Result {cons("ParseOutput")}
    
    "parse" "contains" ATerm -> Result {cons("containspattern")}

    "parse" "fails"      -> Result {cons("FailsParsing")}
    "parse" "succeeds"   -> Result {cons("SuccessParsing"), prefer}
    "parse"              -> Result {cons("SuccessParsing")}

    "desugar" "to" Desugar -> Result {cons("ParseDesugar")}
    "desugar" "contains" ATerm -> Result {cons("desugarcontainspattern")}
	
    
    %% Handle a couple of lousy recoveries
    "test"  -> ATerm {reject}
    "setup" -> ATerm {reject}
            -> "fails" {recover, reject}
            -> "=>" {recover, reject}
            -> "->" {recover, reject}
            -> "/" {recover, reject}
 
context-free syntax

    "_"                  -> ATerm  {cons("wildcard")}
    "..."                -> { ATerm ","}+ {cons("wildcardvar")}

  sorts
  syntax
      
    <Bracket2-LEX> <StringPart2-CF> <TailParts2-CF> <CBracket2-LEX> -> <Input-CF> {cons("Input")}
    <Bracket3-LEX> <StringPart3-CF> <TailParts3-CF> <CBracket3-LEX> -> <Input-CF> {cons("Input")}
    <Bracket4-LEX> <StringPart4-CF> <TailParts4-CF> <CBracket4-LEX> -> <Input-CF> {cons("Input")}

    <Bracket2-LEX> <StringPart2-CF> <TailParts2-CF> <CBracket2-CF> -> <Output-CF> {cons("Output")}
    <Bracket3-LEX> <StringPart3-CF> <TailParts3-CF> <CBracket3-CF> -> <Output-CF> {cons("Output")}
    <Bracket4-LEX> <StringPart4-CF> <TailParts4-CF> <CBracket4-CF> -> <Output-CF> {cons("Output")}
    
    <Bracket2-LEX> <StringPart2-CF> <TailParts2-CF> <CBracket2-CF> -> <Desugar-CF> {cons("Desugar")}
    <Bracket3-LEX> <StringPart3-CF> <TailParts3-CF> <CBracket3-CF> -> <Desugar-CF> {cons("Desugar")}
    <Bracket4-LEX> <StringPart4-CF> <TailParts4-CF> <CBracket4-CF> -> <Desugar-CF> {cons("Desugar")}

                                                      -> <TailParts2-CF> {cons("Done")}
    <MarkedPart2-CF> <StringPart2-CF> <TailParts2-CF> -> <TailParts2-CF> {cons("More")}
                                                      -> <TailParts3-CF> {cons("Done")}
    <MarkedPart3-CF> <StringPart3-CF> <TailParts3-CF> -> <TailParts3-CF> {cons("More")}
                                                      -> <TailParts4-CF> {cons("Done")}
    <MarkedPart4-CF> <StringPart4-CF> <TailParts4-CF> -> <TailParts4-CF> {cons("More")}
    
    <NFBracket2-LEX> <StringPart2-CF> <NFCBracket2-LEX> -> <MarkedPart2-CF> {cons("Marked")}
    <NFBracket3-LEX> <StringPart3-CF> <NFCBracket3-LEX> -> <MarkedPart3-CF> {cons("Marked")}
    <NFBracket4-LEX> <StringPart4-CF> <NFCBracket4-LEX> -> <MarkedPart4-CF> {cons("Marked")}
    
    <NFBracket2-LEX> <ThreeDots-LEX> <NFCBracket2-LEX> -> <MarkedPart2-CF> {cons("MarkedPlaceholder"), prefer}
    <NFBracket3-LEX> <ThreeDots-LEX> <NFCBracket3-LEX> -> <MarkedPart3-CF> {cons("MarkedPlaceholder"), prefer}
    <NFBracket4-LEX> <ThreeDots-LEX> <NFCBracket4-LEX> -> <MarkedPart4-CF> {cons("MarkedPlaceholder"), prefer}
    
    <InputChars2-LEX> -> <StringPart2-CF> {cons("QuotePart")}
    <InputChars3-LEX> -> <StringPart3-CF> {cons("QuotePart")}
    <InputChars4-LEX> -> <StringPart4-CF> {cons("QuotePart")}

  context-free syntax
    EOLString -> Description {cons("description")}

  lexical syntax

    (~[\n\[\"]|EOLQuote1)* -> EOLString
    [\"]                   -> EOLQuote1
    
  lexical syntax

    (~[\[\]]  | Bracket1 | CBracket1)*                         -> InputChars2
    (~[\[\]]  | Bracket1 | Bracket2 | CBracket1 | CBracket2)*  -> InputChars3
    (~[\[\]]  | Bracket1 | Bracket2 | Bracket3 
              | CBracket1 | CBracket2 | CBracket3)*            -> InputChars4

    "["    -> Bracket1
    "[["   -> Bracket2
    "[[["  -> Bracket3
    "[[[[" -> Bracket4

    "]"    -> CBracket1
    "]]"   -> CBracket2
    "]]]"  -> CBracket3
    "]]]]" -> CBracket4
    
    "..."  -> ThreeDots
 
    %% non-follow-restricted:

    "["    -> NFBracket1
    "[["   -> NFBracket2
    "[[["  -> NFBracket3
    "[[[[" -> NFBracket4
    
    "]"    -> NFCBracket1
    "]]"   -> NFCBracket2
    "]]]"  -> NFCBracket3
    "]]]]" -> NFCBracket4

  lexical restrictions
    EOLString -/- ~[\n\[\"]
    EOLQuote1 -/- [\"]
    
    Bracket1   -/- [\[].~[\[]
    Bracket2   -/- [\[].~[\[] %% allow [[[[x]]  ]]
    Bracket3   -/- [\[].~[\[]

    CBracket1   -/- [\]]
    CBracket2   -/- [\]]
    CBracket3   -/- [\]]

  sorts ShortCom LongCom CommChar Asterisk 
  lexical syntax
    "//" ~[\n]* ([\n] | EOF) -> ShortCom
    "/*" CommChar* "*/"      -> LongCom

    ~[\*]      -> CommChar

    "*"        -> Asterisk
    Asterisk   -> CommChar

  lexical restrictions
    Asterisk -/- [\/]

  lexical syntax
    ShortCom    -> LAYOUT
    LongCom     -> LAYOUT
   
  context-free restrictions
    LAYOUT? -/- [\/]/[\/]
    LAYOUT? -/- [\/].[\*]

