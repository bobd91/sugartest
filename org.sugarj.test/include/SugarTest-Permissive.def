definition

module RegExp
exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    [A-Za-z0-9\_]                  -> WATERTOKENSTART       {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN            
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR   {recover, avoid}
    "*"                            -> WATERTOKENSTAR        {recover, avoid}
    WATERTOKEN                     -> WATER                 
    WATERTOKENSEPARATOR            -> WATER                 
    WATERTOKENSTAR                 -> WATER                 
                                   -> WATEREOF              
    "completion123"                -> COMPLETIONPREFIX      {completion}
    "|#WATERTOKENSTAR|"            -> WATERTOKENSTAR        {completion}
    "|#RegexExp|"                  -> RegexExp              {completion}
    "|#Pattern|"                   -> Pattern               {completion}
    "|#Quantifier|"                -> Quantifier            {completion}
    "|#Atom|"                      -> Atom                  {completion}
    "|#CharacterClass|"            -> CharacterClass        {completion}
    "|#BracketItem|"               -> BracketItem           {completion}
    "|#ClassKeyword|"              -> ClassKeyword          {completion}
    "|#BracketLiteral|"            -> BracketLiteral        {completion}
    "|#AllChars|"                  -> AllChars              {completion}
    "|#AtomCharacter|"             -> AtomCharacter         {completion}
    "|#BracketCharacter|"          -> BracketCharacter      {completion}
    "|#QuotablePatternSymbol|"     -> QuotablePatternSymbol {completion}
    "|#RegexID|"                   -> RegexID               {completion}
    "|#StrChar|"                   -> StrChar               {completion}
    "|#OptExp|"                    -> OptExp                {completion}
    "|#RealCon|"                   -> RealCon               {completion}
    "|#Annotation|"                -> Annotation            {completion}
    "|#StringQuotedPart1|"         -> StringQuotedPart1     {completion}
    "|#Dollar1|"                   -> Dollar1               {completion}
    "|#StringQuotedPart2|"         -> StringQuotedPart2     {completion}
    "|#Dollar2|"                   -> Dollar2               {completion}
    "|#StringQuotedPart3|"         -> StringQuotedPart3     {completion}
    "|#Dollar3|"                   -> Dollar3               {completion}
    "|#StringQuotation|"           -> StringQuotation       {completion}
    "|#StringQuotedPart4|"         -> StringQuotedPart4     {completion}
    "|#Dollar4|"                   -> Dollar4               {completion}
    "|#STRING|"                    -> STRING                {completion}
    "|#StringChar|"                -> StringChar            {completion}
    "|#BackSlashChar|"             -> BackSlashChar         {completion}
    "|#TestSuite|"                 -> TestSuite             {completion}
    "|#Header|"                    -> Header                {completion}
    "|#Test|"                      -> Test                  {completion}
    "|#VarDecl|"                   -> VarDecl               {completion}
    "|#Input|"                     -> Input                 {completion}
    "|#OptArgument|"               -> OptArgument           {completion}
    "|#OptPattern|"                -> OptPattern            {completion}
    "|#Numbered|"                  -> Numbered              {completion}
    "|#ID|"                        -> ID                    {completion}
    "|#Result|"                    -> Result                {completion}
    "|#ATerm|"                     -> ATerm                 {completion}
    "|#Bracket1|"                  -> Bracket1              {completion}
    "|#Bracket2|"                  -> Bracket2              {completion}
    "|#Bracket3|"                  -> Bracket3              {completion}
    "|#Bracket4|"                  -> Bracket4              {completion}
    "|#CBracket1|"                 -> CBracket1             {completion}
    "|#CBracket2|"                 -> CBracket2             {completion}
    "|#CBracket3|"                 -> CBracket3             {completion}
    "|#CBracket4|"                 -> CBracket4             {completion}
    "|#ThreeDots|"                 -> ThreeDots             {completion}
    "|#NFBracket1|"                -> NFBracket1            {completion}
    "|#NFBracket2|"                -> NFBracket2            {completion}
    "|#NFBracket3|"                -> NFBracket3            {completion}
    "|#NFBracket4|"                -> NFBracket4            {completion}
    "|#NFCBracket1|"               -> NFCBracket1           {completion}
    "|#NFCBracket2|"               -> NFCBracket2           {completion}
    "|#NFCBracket3|"               -> NFCBracket3           {completion}
    "|#NFCBracket4|"               -> NFCBracket4           {completion}
    "|#ShortCom|"                  -> ShortCom              {completion}
    "|#LongCom|"                   -> LongCom               {completion}
    "|#Asterisk|"                  -> Asterisk              {completion}

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                     
                                         -> "/"             {recover, cons("INSERTION")}
                                         -> "}?"            {recover, cons("INSERTION")}
                                         -> "}+"            {recover, cons("INSERTION")}
                                         -> "\\E"           {recover, cons("INSERTION")}
                                         -> "\\0"           {recover, cons("INSERTION")}
                                         -> "\\x"           {recover, cons("INSERTION")}
                                         -> "\\u"           {recover, cons("INSERTION")}
                                         -> "\\c"           {recover, cons("INSERTION")}
                                         -> "\\"            {recover, cons("INSERTION")}
                                         -> "e"             {recover, cons("INSERTION")}
                                         -> "."             {recover, cons("INSERTION")}
                                         -> "+"             {recover, cons("INSERTION")}
                                         -> "-"             {recover, cons("INSERTION")}
                                         -> ">"             {recover, cons("INSERTION")}
                                         -> "]"             {recover, cons("INSERTION")}
                                         -> "}"             {recover, cons("INSERTION")}
    "\""                                 -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE StringChar* "\n"     -> STRING          {cons("INSERTEND")}
    INSERTOPENQUOTE StringChar* WATEREOF -> STRING          {cons("INSERTEND")}
                                         -> "module"        {recover, cons("INSERTION")}
                                         -> "package"       {recover, cons("INSERTION")}
                                         -> "start"         {recover, cons("INSERTION")}
                                         -> "language"      {recover, cons("INSERTION")}
                                         -> "tests"         {recover, cons("INSERTION")}
                                         -> "target"        {recover, cons("INSERTION")}
                                         -> "fails"         {recover, cons("INSERTION")}
                                         -> "succeeds"      {recover, cons("INSERTION")}
                                         -> "file"          {recover, cons("INSERTION")}
                                         -> "resolve"       {recover, cons("INSERTION")}
                                         -> "complete"      {recover, cons("INSERTION")}
                                         -> "build"         {recover, cons("INSERTION")}
                                         -> "run"           {recover, cons("INSERTION")}
                                         -> "refactor"      {recover, cons("INSERTION")}
                                         -> ")"             {recover, cons("INSERTION")}
                                         -> "to"            {recover, cons("INSERTION")}
                                         -> "#"             {recover, cons("INSERTION")}
                                         -> "COMPLETION"    {recover, cons("INSERTION")}
                                         -> ","             {recover, cons("INSERTION")}
    "/*"                                 -> INSERTSTART     {recover}
    INSERTSTART CommChar* WATEREOF       -> LongCom         {cons("INSERTEND")}

  syntax
    %% Kernel syntax insertion recovery rules                          
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket1-LEX> "\n"     -> StringQuotedPart1 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket1-LEX> WATEREOF -> StringQuotedPart1 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket2-LEX> "\n"     -> StringQuotedPart2 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket2-LEX> WATEREOF -> StringQuotedPart2 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket3-LEX> "\n"     -> StringQuotedPart3 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket3-LEX> WATEREOF -> StringQuotedPart3 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket4-LEX> "\n"     -> StringQuotedPart4 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket4-LEX> WATEREOF -> StringQuotedPart4 {cons("INSERTEND")}

  )

  (

  sorts Pattern PatternDecl Exp

  context-free syntax
    "/" Pattern "/"     -> RegexExp {cons("RegexPattern")}
    Branche             -> Pattern  {cons("SingleBranch")}
    Pattern "|" Pattern -> Pattern  {cons("TupleBranch"), right, prefer}

  sorts Branche

  context-free syntax
    Piece+ -> Branche {cons("Pieces")}

  sorts Piece

  context-free syntax
    Atom            -> Piece {cons("SingleAtom")}
    Atom Quantifier -> Piece {cons("QuantifiedAtom")}

  sorts Quantifier

  context-free syntax
    "{" Integer "}"              -> Quantifier {cons("GreedyExactBound")}
    "{" Integer "," "}"          -> Quantifier {cons("GreedyLowerBound")}
    "{" Integer "," Integer "}"  -> Quantifier {cons("GreedyLowerUpperBound")}
    "?"                          -> Quantifier {cons("GreedyOnceOrNot")}
    "*"                          -> Quantifier {cons("GreedyZeroOrMore")}
    "+"                          -> Quantifier {cons("GreedyOneOrMore")}
    "{" Integer "}?"             -> Quantifier {cons("ReluctantExactBound")}
    "{" Integer "," "}?"         -> Quantifier {cons("ReluctantLowerBound")}
    "{" Integer "," Integer "}?" -> Quantifier {cons("ReluctantLowerUpperBound")}
    "??"                         -> Quantifier {cons("ReluctantOnceOrNot")}
    "*?"                         -> Quantifier {cons("ReluctantZeroOrMore")}
    "+?"                         -> Quantifier {cons("ReluctantOneOrMore")}
    "{" Integer "}+"             -> Quantifier {cons("PossessiveExactBound")}
    "{" Integer "," "}+"         -> Quantifier {cons("PossessiveLowerBound")}
    "{" Integer "," Integer "}+" -> Quantifier {cons("PossessiveLowerUpperBound")}
    "?+"                         -> Quantifier {cons("PossessiveOnceOrNot")}
    "*+"                         -> Quantifier {cons("PossessiveZeroOrMore")}
    "++"                         -> Quantifier {cons("PossessiveOneOrMore")}

  sorts Atom

  context-free syntax
    "(" Pattern ")"                -> Atom {cons("Capture")}
    "(?:" Pattern ")"              -> Atom {cons("NonCapture")}
    "(?=" Pattern ")"              -> Atom {cons("PositiveLookahead")}
    "(?!" Pattern ")"              -> Atom {cons("NegativeLookahead")}
    "(?<=" Pattern ")"             -> Atom {cons("PositiveLookbehind")}
    "(?<!" Pattern ")"             -> Atom {cons("NegativeLookbehind")}
    "(?P<" RegexId ">" Pattern ")" -> Atom {cons("PythonCapture")}
    "(" Pattern ")@{" RegexId "}"  -> Atom {cons("RegexCapture")}
    "()"                           -> Atom {cons("Empty")}
    "."                            -> Atom {cons("SingleCharacter")}
    "^"                            -> Atom {cons("LineStart")}
    "$"                            -> Atom {cons("LineEnd")}
    CharacterClass                 -> Atom {cons("CharacterClass")}
    AtomLiteral                    -> Atom {cons("AtomLiteral")}
    AtomCharacter                  -> Atom {cons("AtomCharacter")}
    "\\Q" AllChars "\\E"           -> Atom {cons("QuotedAtom")}

  sorts CharacterClass BracketItem

  context-free syntax
    "[" BracketItem+ "]"                                                    -> CharacterClass {cons("BracketList")}
    "[^" BracketItem+ "]"                                                   -> CharacterClass {cons("NegatedBracketList")}
    BracketLiteral | BracketCharacter "-" BracketLiteral | BracketCharacter -> BracketItem    {cons("Range")}
    CharacterClass                                                          -> BracketItem    {cons("Union")}
    BracketLiteral                                                          -> BracketItem    {cons("BracketLiteral")}
    BracketCharacter                                                        -> BracketItem    {cons("BracketCharacter")}

  sorts ClassKeyword

  context-free syntax
    "Lower"          -> ClassKeyword {cons("LowerClass")}
    "Upper"          -> ClassKeyword {cons("UpperClass")}
    "ASCII"          -> ClassKeyword {cons("ASCIIClass")}
    "Alpha"          -> ClassKeyword {cons("AlphaClass")}
    "Digit"          -> ClassKeyword {cons("DigitClass")}
    "Alnum"          -> ClassKeyword {cons("AlnumClass")}
    "Punct"          -> ClassKeyword {cons("PunctClass")}
    "Graph"          -> ClassKeyword {cons("GraphClass")}
    "Print"          -> ClassKeyword {cons("PrintClass")}
    "Blank"          -> ClassKeyword {cons("BlankClass")}
    "Cntrl"          -> ClassKeyword {cons("CntrlClass")}
    "XDigit"         -> ClassKeyword {cons("XDigitClass")}
    "Space"          -> ClassKeyword {cons("WhiteSpace")}
    "javaLowerCase"  -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaUpperCase"  -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaWhitespace" -> ClassKeyword {cons("JavaIsWhitespace")}
    "javaMirrored"   -> ClassKeyword {cons("JavaIsMirrored")}
    "InGreek"        -> ClassKeyword {cons("GreekBlock")}
    "Lu"             -> ClassKeyword {cons("UppercaseLetter")}
    "Sc"             -> ClassKeyword {cons("CurrencySymbol")}

  sorts BracketLiteral AtomLiteral AllChars

  lexical syntax
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\$\*\+\?\.\}\|]                          -> BracketLiteral 
    "/"                                                                            -> BracketLiteral 
    [\&\]\-]                                                                       -> BracketLiteral {reject}
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\&\]\-]                                  -> AtomLiteral    
    [\}\)\|\[]                                                                     -> AtomLiteral    {reject}
    [\\\|\$\*\+\?\.\{\}\(\)\&\]\-\[\^\!\#\%\'\,\:\;\<\=\>\@\_\`\~a-zA-Z0-9\t\n\r]* -> AllChars       
    "/"                                                                            -> AllChars       
    "\""                                                                           -> AllChars       {cons("DoubleQuote")}

  sorts BracketCharacter AtomCharacter

  context-free syntax
    "\"" -> BracketCharacter {cons("DoubleQuote")}
    "\"" -> AtomCharacter    {cons("DoubleQuote")}

  context-free syntax
    "\\0" OctalValue   -> BracketCharacter {cons("OctalChar")}
    "\\x" TwoHexValue  -> BracketCharacter {cons("HexHexChar")}
    "\\u" FourHexValue -> BracketCharacter {cons("DecHexChar")}
    "\\t"              -> BracketCharacter {cons("Tab")}
    "\\n"              -> BracketCharacter {cons("Newline")}
    "\\r"              -> BracketCharacter {cons("Return")}
    "\\f"              -> BracketCharacter {cons("Formfeed")}
    "\\a"              -> BracketCharacter {cons("Alarm")}
    "\\e"              -> BracketCharacter {cons("Escape")}
    "\\w"              -> BracketCharacter {cons("WordChar")}
    "\\W"              -> BracketCharacter {cons("NonWordChar")}
    "\\s"              -> BracketCharacter {cons("WhiteSpaceChar")}
    "\\S"              -> BracketCharacter {cons("NonWhiteSpaceChar")}
    "\\d"              -> BracketCharacter {cons("DigitChar")}
    "\\D"              -> BracketCharacter {cons("NonDigitChar")}
    "\\c" ControlValue -> BracketCharacter {cons("ControlCharacter")}
    "\\b"              -> BracketCharacter {cons("WordBoundry")}
    "\\B"              -> BracketCharacter {cons("NonWordBoundry")}
    "\\A"              -> BracketCharacter {cons("InputBeginBoundry")}
    "\\G"              -> BracketCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"              -> BracketCharacter {cons("EndInputBoundry")}
    "\\z"              -> BracketCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference -> BracketCharacter {cons("BackReference")}
    "\\ "              -> BracketCharacter {cons("Space")}
    "\\\t"             -> BracketCharacter {cons("Tab")}
    "\\\n"             -> BracketCharacter {cons("Newline")}
    "\\0" OctalValue   -> AtomCharacter    {cons("OctalChar")}
    "\\x" TwoHexValue  -> AtomCharacter    {cons("HexHexChar")}
    "\\u" FourHexValue -> AtomCharacter    {cons("DecHexChar")}
    "\\t"              -> AtomCharacter    {cons("Tab")}
    "\\n"              -> AtomCharacter    {cons("Newline")}
    "\\r"              -> AtomCharacter    {cons("Return")}
    "\\f"              -> AtomCharacter    {cons("Formfeed")}
    "\\a"              -> AtomCharacter    {cons("Alarm")}
    "\\e"              -> AtomCharacter    {cons("Escape")}
    "\\w"              -> AtomCharacter    {cons("WordChar")}
    "\\W"              -> AtomCharacter    {cons("NonWordChar")}
    "\\s"              -> AtomCharacter    {cons("WhiteSpaceChar")}
    "\\S"              -> AtomCharacter    {cons("NonWhiteSpaceChar")}
    "\\d"              -> AtomCharacter    {cons("DigitChar")}
    "\\D"              -> AtomCharacter    {cons("NonDigitChar")}
    "\\c" ControlValue -> AtomCharacter    {cons("ControlCharacter")}
    "\\b"              -> AtomCharacter    {cons("WordBoundry")}
    "\\B"              -> AtomCharacter    {cons("NonWordBoundry")}
    "\\A"              -> AtomCharacter    {cons("InputBeginBoundry")}
    "\\G"              -> AtomCharacter    {cons("PrevMatchEndBoundry")}
    "\\Z"              -> AtomCharacter    {cons("EndInputBoundry")}
    "\\z"              -> AtomCharacter    {cons("EndInputFinalBoundry")}
    "\\" BackReference -> AtomCharacter    {cons("BackReference")}
    "\\ "              -> AtomCharacter    {cons("Space")}
    "\\\t"             -> AtomCharacter    {cons("Tab")}
    "\\\n"             -> AtomCharacter    {cons("Newline")}

  sorts QuotablePatternSymbol

  context-free syntax
    "\\" QuotablePatternSymbol -> AtomCharacter    {cons("Quoted")}
    "\\" QuotablePatternSymbol -> BracketCharacter {cons("Quoted")}

  lexical syntax
    [\|\$\*\+\?\.\{\}\(\)\&\]\[\-\^\\\!\#\%\'\,\:\;\<\=\>\@\_\`\~\/] -> QuotablePatternSymbol 

  context-free syntax
    "\"" -> QuotablePatternSymbol {cons("DoubleQuote")}
    "\"" -> QuotablePatternSymbol {cons("DoubleQuote")}

  sorts Integer OctalValue TwoHexValue FourHexValue BackReference ControlValue

  lexical syntax
    [0-9]+                                          -> Integer       
    [1-9] [0-9]*                                    -> BackReference 
    [0-7]                                           -> OctalValue    
    [0-7] [0-7]                                     -> OctalValue    
    [0-3] [0-7] [0-7]                               -> OctalValue    
    [0-9A-Fa-f] [0-9A-Fa-f]                         -> TwoHexValue   
    [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f] -> FourHexValue  
    [0-9]                                           -> ControlValue  
    [0-9] [0-9]                                     -> ControlValue  

  )

exports
  sorts RegexId RegexID

  context-free syntax
    RegexID -> RegexId {cons("RegexId")}

  lexical syntax
    [A-Za-z\_\$] [A-Za-z0-9\_\$]* -> RegexID 
    "true"                        -> RegexID {reject}
    "false"                       -> RegexID {reject}
    "null"                        -> RegexID {reject}

  lexical restrictions
    RegexID -/- [a-zA-Z0-9\_\$]

module basic/IdentifierCon
exports
  sorts IdCon

  lexical syntax
    head:[A-Za-z] tail:[A-Za-z\-0-9\_]* -> IdCon {cons("default")}

  lexical restrictions
    IdCon -/- [A-Za-z\-0-9\_]

module basic/StrCon
exports
  sorts StrCon StrChar

  lexical syntax
    "\\n"                        -> StrChar {cons("newline")}
    "\\t"                        -> StrChar {cons("tab")}
    "\\\""                       -> StrChar {cons("quote")}
    "\\\\"                       -> StrChar {cons("backslash")}
    "\\" a:[0-9] b:[0-9] c:[0-9] -> StrChar {cons("decimal")}
    ~[\0-\31\n\t\"\\]            -> StrChar {cons("normal")}
    [\"] chars:StrChar* [\"]     -> StrCon  {cons("default")}

module languages/aterm/syntax/RealCon
imports languages/aterm/syntax/IntCon

hiddens
  context-free start-symbols
    RealCon

exports
  sorts OptExp RealCon

  context-free syntax
    "e" IntCon                                -> OptExp  {cons("present")}
                                              -> OptExp  {cons("absent")}
    base:IntCon "." decimal:NatCon exp:OptExp -> RealCon {cons("real-con")}

module basic/NatCon
exports
  sorts NatCon

  lexical syntax
    [0-9]+ -> NatCon {cons("digits")}

  lexical restrictions
    NatCon -/- [0-9]

module basic/Whitespace
exports
  lexical syntax
    [\ \t\n\r] -> LAYOUT {cons("whitespace")}

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]

module languages/aterm/syntax/IntCon
imports basic/Whitespace basic/NatCon

hiddens
  context-free start-symbols
    IntCon

exports
  sorts IntCon

  context-free syntax
    NatCon         -> IntCon {cons("natural")}
    pos:"+" NatCon -> IntCon {cons("positive")}
    neg:"-" NatCon -> IntCon {cons("negative")}

module languages/aterm/syntax/ATerms
imports languages/aterm/syntax/IntCon languages/aterm/syntax/RealCon
        basic/StrCon basic/IdentifierCon

exports
  sorts AFun ATerm Annotation

  context-free syntax
    StrCon -> AFun {cons("quoted")}
    IdCon  -> AFun {cons("unquoted")}

  context-free syntax
    IntCon                             -> ATerm {cons("int")}
    RealCon                            -> ATerm {cons("real")}
    fun:AFun                           -> ATerm {cons("fun")}
    fun:AFun "(" args:{ATerm ","}* ")" -> ATerm {cons("appl")}
    NoAFun "(" args:{ATerm ","}* ")"   -> ATerm {cons("appl")}
    "<" type:ATerm ">"                 -> ATerm {cons("placeholder")}
    "[" elems:{ATerm ","}* "]"         -> ATerm {cons("list")}
    trm:ATerm Annotation               -> ATerm {cons("annotated")}

  lexical syntax
     -> NoAFun 

  context-free syntax
    "{" annos:{ATerm ","}+ "}" -> Annotation {cons("default")}

hiddens
  context-free start-symbols
    ATerm

module SugarTest-String-Quotation
exports
  sorts StringQuotation StringQuotedPart1 StringQuotedChars1 DollarOpen1
        DollarClose1 QuotedBracket1 Dollar1 StringQuotedPart2 StringQuotedChars2
        DollarOpen2 DollarClose2 QuotedBracket2 Dollar2 StringQuotedPart3
        StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
        StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4
        QuotedBracket4 Dollar4 Padding

  context-free syntax
    StringQuotation -> PreTerm 

  syntax
    StringQuotation                        -> <PreTerm-CF>             
    "$" "[" Padding StringQuotedPart1* "]" -> StringQuotation          {cons("StringQuotation1")}
    <StringQuotedChars1-LEX>               -> StringQuotedPart1        {cons("QStr")}
    <Dollar1-LEX>                          -> StringQuotedPart1        {cons("QDollar")}
    "$" <QuotedBracket1-LEX> "$"           -> StringQuotedPart1        {cons("QBr")}
    ~[\[\]\$]+                             -> <StringQuotedChars1-LEX> 
    [\[\]]                                 -> <QuotedBracket1-LEX>     
    "$"                                    -> <Dollar1-LEX>            
    "$" "{" Padding StringQuotedPart2* "}" -> StringQuotation          {cons("StringQuotation2")}
    <StringQuotedChars2-LEX>               -> StringQuotedPart2        {cons("QStr")}
    <Dollar2-LEX>                          -> StringQuotedPart2        {cons("QDollar")}
    "$" <QuotedBracket2-LEX> "$"           -> StringQuotedPart2        {cons("QBr")}
    ~[\{\}\$]+                             -> <StringQuotedChars2-LEX> 
    [\{\}]                                 -> <QuotedBracket2-LEX>     
    "$"                                    -> <Dollar2-LEX>            
    "$" "(" Padding StringQuotedPart3* ")" -> StringQuotation          {cons("StringQuotation3")}
    <StringQuotedChars3-LEX>               -> StringQuotedPart3        {cons("QStr")}
    <Dollar3-LEX>                          -> StringQuotedPart3        {cons("QDollar")}
    "$" <QuotedBracket3-LEX> "$"           -> StringQuotedPart3        {cons("QBr")}
    ~[\(\)\$]+                             -> <StringQuotedChars3-LEX> 
    [\(\)]                                 -> <QuotedBracket3-LEX>     
    "$"                                    -> <Dollar3-LEX>            
    "$" "<" Padding StringQuotedPart4* ">" -> StringQuotation          {cons("StringQuotation4")}
    <StringQuotedChars4-LEX>               -> StringQuotedPart4        {cons("QStr")}
    <Dollar4-LEX>                          -> StringQuotedPart4        {cons("QDollar")}
    "$" <QuotedBracket4-LEX> "$"           -> StringQuotedPart4        {cons("QBr")}
    ~[\<\>\$]+                             -> <StringQuotedChars4-LEX> 
    [\<\>]                                 -> <QuotedBracket4-LEX>     
    "$"                                    -> <Dollar4-LEX>            
    <Padding-LEX>                          -> Padding                  
                                           -> <Padding-LEX>            {indentpadding}

  lexical restrictions
    StringQuotedChars1 -/- ~[\[\]\$]
    StringQuotedChars2 -/- ~[\{\}\$]
    StringQuotedChars3 -/- ~[\(\)\$]
    StringQuotedChars4 -/- ~[\<\>\$]
    Dollar1 -/- [\[\]] . [\$]
    Dollar2 -/- [\{\}] . [\$]
    Dollar3 -/- [\(\)] . [\$]
    Dollar4 -/- [\<\>] . [\$]

module Common
exports
  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_\-\$\']* -> ID            {prefer}
    "-"? [0-9]+                   -> INT           
    "\"" StringChar* "\""         -> STRING        
    ~[\"\n]                       -> StringChar    
    "\\\""                        -> StringChar    
    BackSlashChar                 -> StringChar    
    "\\"                          -> BackSlashChar 
                                  -> EOF           

  lexical restrictions
    INT -/- [0-9]
    ID -/- [a-zA-Z0-9\_\-\$\']
    EOF -/- ~[]
    BackSlashChar -/- [\"]

  context-free restrictions

module SugarTest
imports Common

imports SugarTest-String-Quotation

imports languages/aterm/syntax/ATerms

imports RegExp

exports
  context-free start-symbols
    TestSuite

exports
  sorts TestSuite TopSort Test Input Result

  context-free syntax
    Header* TestDecl*              -> TestSuite {cons("testsuite")}
    "COMPLETION" ID                -> TestSuite {cons("CompletionHelper")}
    "module" ID                    -> Header    {cons("Name")}
    "package" ID                   -> Header    {cons("Package")}
    "start" "symbol" ID            -> Header    {cons("TopSort")}
    "language" ID                  -> Header    {cons("Language")}
    "disable" "completion" "tests" -> Header    {cons("CompletionDisable")}
    "target" "start" "symbol" ID   -> Header    {cons("TargetTopSort")}
    "target" "language" ID         -> Header    {cons("TargetLanguage")}
    Test                           -> TestDecl  
    VarDecl                        -> TestDecl  

  syntax
    "setup" <OptSpace-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF>                          -> <Test-CF> {cons("Setup")}
    "setup" <OptSpace-LEX> <Description-CF>                                                  -> <Test-CF> {cons("SetupEmpty")}
    "target" <LAYOUT?-CF> "setup" <OptSpace-LEX> <Description-CF> <LAYOUT?-CF> <Output-CF>   -> <Test-CF> {cons("TargetSetup")}
    "target" <LAYOUT?-CF> "setup" <OptSpace-LEX> <Description-CF>                            -> <Test-CF> {cons("TargetSetupEmpty")}
    "test" <OptSpace-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result*-CF> -> <Test-CF> {cons("Test")}
    "test" <OptSpace-LEX> <Description-CF>                                                   -> <Test-CF> {cons("TestEmpty")}

  context-free syntax
    ID "=" ATerm -> VarDecl {cons("VarDecl")}

  lexical syntax
    [\ ]+   -> OptSpace 
    NoSpace -> OptSpace 
            -> NoSpace  

  lexical restrictions
    OptSpace -/- [\ ]
    NoSpace -/- ~[\[] . ~[\[]

  context-free syntax
    "parse" "to" "file" PathName         -> Result      {cons("file")}
    "parse" "to" ATerm                   -> Result      {cons("pattern")}
    "parse" "to" Output                  -> Result      {cons("ParseOutput")}
    "parse" "fails"                      -> Result      {cons("FailsParsing")}
    "parse" "succeeds"                   -> Result      {cons("SuccessParsing"), prefer}
    "parse"                              -> Result      {cons("SuccessParsing")}
    "file" PathName                      -> Input       {cons("file")}
    INT "error"                          -> Result      {cons("Error")}
    INT "errors"                         -> Result      {cons("Errors")}
    INT "warning"                        -> Result      {cons("Warning")}
    INT "warnings"                       -> Result      {cons("Warnings")}
    INT "note"                           -> Result      {cons("Note")}
    INT "notes"                          -> Result      {cons("Notes")}
    INT "fatal" "error"                  -> Result      {cons("Fatal")}
    INT "fatal" "errors"                 -> Result      {cons("Fatals")}
    "resolve" OptNumbered                -> Result      {cons("Resolve")}
    "resolve" Numbered "to" Numbered     -> Result      {cons("ResolveTo")}
    "complete" OptNumbered               -> Result      {cons("Complete")}
    "complete" OptNumbered "to" STRING   -> Result      {cons("CompleteTo")}
    "build" ID OptArgument OptPattern    -> Result      {cons("Build")}
    "run" ID OptArgument OptPattern      -> Result      {cons("Run")}
    "refactor" ID OptArgument OptPattern -> Result      {cons("Refactor")}
                                         -> OptArgument {cons("None")}
    "(" STRING ")"                       -> OptArgument {cons("Argument")}
                                         -> OptPattern  {cons("wildcard")}
    "to" "file" PathName                 -> OptPattern  {cons("File")}
    "to" Output                          -> OptPattern  {cons("Fragment")}
    "to" ATerm                           -> OptPattern  {cons("ATerm"), avoid}
    "fails"                              -> OptPattern  {cons("Fails"), prefer}
    RegexExp                             -> Result      
    "#" INT                              -> Numbered    {cons("Numbered")}
    Numbered                             -> OptNumbered 
                                         -> OptNumbered {cons("Unnumbered")}
    "test"                               -> ID          {reject}
    "setup"                              -> ID          {reject}
    "test"                               -> ATerm       {reject}
    "setup"                              -> ATerm       {reject}
                                         -> "fails"     {recover, reject}
                                         -> "resolves"  {recover, reject}
                                         -> "=>"        {recover, reject}
                                         -> "->"        {recover, reject}
                                         -> "/"         {recover, reject}
                                         -> "file"      {recover, reject}
    "COMPLETION" ID                      -> Result      {cons("CompletionHelper")}

  context-free syntax
    "_"   -> ATerm        {cons("wildcard")}
    "..." -> {ATerm ","}+ {cons("wildcardvar")}

  sorts 

  syntax
    <Bracket2-LEX> <StringPart2-CF> <TailParts2-CF> <CBracket2-LEX> -> <Input-CF>       {cons("Input")}
    <Bracket3-LEX> <StringPart3-CF> <TailParts3-CF> <CBracket3-LEX> -> <Input-CF>       {cons("Input")}
    <Bracket4-LEX> <StringPart4-CF> <TailParts4-CF> <CBracket4-LEX> -> <Input-CF>       {cons("Input")}
    <Bracket2-LEX> <StringPart2-CF> <TailParts2-CF> <CBracket2-CF>  -> <Output-CF>      {cons("Output")}
    <Bracket3-LEX> <StringPart3-CF> <TailParts3-CF> <CBracket3-CF>  -> <Output-CF>      {cons("Output")}
    <Bracket4-LEX> <StringPart4-CF> <TailParts4-CF> <CBracket4-CF>  -> <Output-CF>      {cons("Output")}
                                                                    -> <TailParts2-CF>  {cons("Done")}
    <MarkedPart2-CF> <StringPart2-CF> <TailParts2-CF>               -> <TailParts2-CF>  {cons("More")}
                                                                    -> <TailParts3-CF>  {cons("Done")}
    <MarkedPart3-CF> <StringPart3-CF> <TailParts3-CF>               -> <TailParts3-CF>  {cons("More")}
                                                                    -> <TailParts4-CF>  {cons("Done")}
    <MarkedPart4-CF> <StringPart4-CF> <TailParts4-CF>               -> <TailParts4-CF>  {cons("More")}
    <NFBracket2-LEX> <StringPart2-CF> <NFCBracket2-LEX>             -> <MarkedPart2-CF> {cons("Marked")}
    <NFBracket3-LEX> <StringPart3-CF> <NFCBracket3-LEX>             -> <MarkedPart3-CF> {cons("Marked")}
    <NFBracket4-LEX> <StringPart4-CF> <NFCBracket4-LEX>             -> <MarkedPart4-CF> {cons("Marked")}
    <NFBracket2-LEX> <ThreeDots-LEX> <NFCBracket2-LEX>              -> <MarkedPart2-CF> {cons("MarkedPlaceholder"), prefer}
    <NFBracket3-LEX> <ThreeDots-LEX> <NFCBracket3-LEX>              -> <MarkedPart3-CF> {cons("MarkedPlaceholder"), prefer}
    <NFBracket4-LEX> <ThreeDots-LEX> <NFCBracket4-LEX>              -> <MarkedPart4-CF> {cons("MarkedPlaceholder"), prefer}
    <InputChars2-LEX>                                               -> <StringPart2-CF> {cons("QuotePart")}
    <InputChars3-LEX>                                               -> <StringPart3-CF> {cons("QuotePart")}
    <InputChars4-LEX>                                               -> <StringPart4-CF> {cons("QuotePart")}

  context-free syntax
    EOLString -> Description {cons("description")}

  lexical syntax
    ( ~[\n\[\"] | EOLQuote1 )* -> EOLString 
    [\"]                       -> EOLQuote1 

  lexical syntax
    ( ~[\[\]] | Bracket1 | CBracket1 )*                                               -> InputChars2 
    ( ~[\[\]] | Bracket1 | Bracket2 | CBracket1 | CBracket2 )*                        -> InputChars3 
    ( ~[\[\]] | Bracket1 | Bracket2 | Bracket3 | CBracket1 | CBracket2 | CBracket3 )* -> InputChars4 
    "["                                                                               -> Bracket1    
    "[["                                                                              -> Bracket2    
    "[[["                                                                             -> Bracket3    
    "[[[["                                                                            -> Bracket4    
    "]"                                                                               -> CBracket1   
    "]]"                                                                              -> CBracket2   
    "]]]"                                                                             -> CBracket3   
    "]]]]"                                                                            -> CBracket4   
    "..."                                                                             -> ThreeDots   
    "["                                                                               -> NFBracket1  
    "[["                                                                              -> NFBracket2  
    "[[["                                                                             -> NFBracket3  
    "[[[["                                                                            -> NFBracket4  
    "]"                                                                               -> NFCBracket1 
    "]]"                                                                              -> NFCBracket2 
    "]]]"                                                                             -> NFCBracket3 
    "]]]]"                                                                            -> NFCBracket4 

  sorts PathName

  lexical syntax
    [A-Za-z0-9\-\_\.\\\/]+ -> PathName 

  lexical restrictions
    EOLString -/- ~[\n\[\"]
    EOLQuote1 -/- [\"]
    Bracket1 -/- [\[] . ~[\[]
    Bracket2 -/- [\[] . ~[\[]
    Bracket3 -/- [\[] . ~[\[]
    CBracket1 -/- [\]]
    CBracket2 -/- [\]]
    CBracket3 -/- [\]]

  sorts ShortCom LongCom CommChar Asterisk

  lexical syntax
    "//" ~[\n]* [\n] | EOF -> ShortCom 
    "/*" CommChar* "*/"    -> LongCom  
    ~[\*]                  -> CommChar 
    "*"                    -> Asterisk 
    Asterisk               -> CommChar 

  lexical restrictions
    Asterisk -/- [\/]

  lexical syntax
    ShortCom -> LAYOUT 
    LongCom  -> LAYOUT 

  context-free restrictions
    LAYOUT? -/- [\/] / [\/]
    LAYOUT? -/- [\/] . [\*]